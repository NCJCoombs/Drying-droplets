// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2022 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for UnsteadyHeat elements
#ifndef OOMPH_THIN_FILM_BRINKMAN_ELEMENTS_HEADER
#define OOMPH_THIN_FILM_BRINKMAN_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// OOMPH-LIB headers
#include "../generic/projection.h"
#include "../generic/nodes.h"
#include "../generic/Qelements.h"
#include "../generic/oomph_utilities.h"


namespace oomph
{
  //=============================================================
  /// A class for all isoparametric elements that solve the
  /// UnsteadyHeat equations.
  /// \f[ \frac{\partial^2 u}{\partial x_i^2}=\frac{\partial u}{\partial t}+f(t,x_j) \f]
  /// This contains the generic maths. Shape functions, geometric
  /// mapping etc. must get implemented in derived class.
  /// Note that this class assumes an isoparametric formulation, i.e. that
  /// the scalar unknown is interpolated using the same shape funcitons
  /// as the position.
  //=============================================================
  template<unsigned DIM>
  class ThinFilmBrinkmanEquations : public virtual FiniteElement
  {
  public:
    /// Function pointer to source function fct(t,x,f(x,t)) --
    /// x is a Vector!
    typedef void (*EvaporationFluxPt)(const double& time,
                                      const Vector<double>& x,
                                      double& J);

    /// Function pointer to transition function
    typedef void (*TransitionFctPt)(const double& c, double& H);

    /// Function pointer to mobility
    typedef void (*MobilityFctPt)(const double& h, const double& c, double& Q);


    /// Constructor: Initialises the Source_fct_pt to null and
    /// sets flag to use ALE formulation of the equations.
    /// Also set Alpha (thermal inertia) and Beta (thermal conductivity)
    /// parameters to defaults (both one for natural scaling)
    ThinFilmBrinkmanEquations()
      : Evap_flux_pt(0),
        Transition_fct_pt(0),
        Transition_fct_deriv_pt(0),
        Mobility_fct_pt(0),
        Mobility_fct_deriv_h_pt(0),
        Mobility_fct_deriv_c_pt(0),
        Solute_mobility_fct_pt(0),
        Solute_mobility_fct_deriv_h_pt(0),
        Solute_mobility_fct_deriv_c_pt(0),
        ALE_is_disabled(false)
    {
      // Set the Peclet number to default
      Pe_pt = &Default_peclet_number;

      // Set the axisymmetry flag to default
      Axisymmetry_flag_pt = &Default_axisymmetry_flag;

      // Set the dry-out time to default
      Dry_out_time_pt = &Default_dryout_time;

      // Set the evaporation flux at integration points pointer to null
      Evap_at_int_points_pt = 0;
    }


    /// Broken copy constructor
    ThinFilmBrinkmanEquations(const ThinFilmBrinkmanEquations& dummy) = delete;

    /// Broken assignment operator
    // Commented out broken assignment operator because this can lead to a
    // conflict warning when used in the virtual inheritence hierarchy.
    // Essentially the compiler doesn't realise that two separate
    // implementations of the broken function are the same and so, quite
    // rightly, it shouts.
    /*void operator=(const UnsteadyHeatEquations&) = delete;*/

    /// Return the index at which the unknown value
    /// is stored. 0 for h (film height). 1 for intermediate variable w =
    /// \nabla^2 h In derived multi-physics elements, this function should be
    /// overloaded to reflect the chosen storage scheme. Note that these
    /// equations require that the unknown is always stored at the same index at
    /// each node.
    virtual inline unsigned u_index_thin_film_brinkman(const unsigned& i) const
    {
      return i;
    }

    /// du/dt at local node n.
    /// Uses suitably interpolated value for hanging nodes.
    double du_dt_thin_film_brinkman(const unsigned& n, const unsigned& i) const
    {
      // Get the data's timestepper
      TimeStepper* time_stepper_pt = this->node_pt(n)->time_stepper_pt();

      // Initialise dudt
      double dudt = 0.0;
      // Loop over the timesteps, if there is a non Steady timestepper
      if (!time_stepper_pt->is_steady())
      {
        // Find the index at which the variable is stored
        const unsigned u_nodal_index = u_index_thin_film_brinkman(i);

        // Number of timsteps (past & present)
        const unsigned n_time = time_stepper_pt->ntstorage();

        // Add the contributions to the time derivative
        for (unsigned t = 0; t < n_time; t++)
        {
          dudt +=
            time_stepper_pt->weight(1, t) * nodal_value(t, n, u_nodal_index);
        }
      }
      return dudt;
    }

    /// Disable ALE, i.e. assert the mesh is not moving -- you do this
    /// at your own risk!
    void disable_ALE()
    {
      ALE_is_disabled = true;
    }


    /// (Re-)enable ALE, i.e. take possible mesh motion into account
    /// when evaluating the time-derivative. Note: By default, ALE is
    /// enabled, at the expense of possibly creating unnecessary work
    /// in problems where the mesh is, in fact, stationary.
    void enable_ALE()
    {
      ALE_is_disabled = false;
    }

    /// Compute norm of fe solution
    void compute_norm(double& norm);

    /// Output with default number of plot points
    void output(std::ostream& outfile)
    {
      unsigned nplot = 5;
      output(outfile, nplot);
    }


    /// Output FE representation of soln: x,y,u or x,y,z,u at
    /// n_plot^DIM plot points
    void output(std::ostream& outfile, const unsigned& nplot);

    /// C_style output with default number of plot points
    void output(FILE* file_pt)
    {
      unsigned n_plot = 5;
      output(file_pt, n_plot);
    }


    /// C-style output FE representation of soln: x,y,u or x,y,z,u at
    /// n_plot^DIM plot points
    void output(FILE* file_pt, const unsigned& n_plot);


    /// Output exact soln: x,y,u_exact or x,y,z,u_exact at nplot^DIM plot points
    void output_fct(std::ostream& outfile,
                    const unsigned& nplot,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);


    /// Output exact soln: x,y,u_exact or x,y,z,u_exact at
    /// nplot^DIM plot points (time-dependent version)
    virtual void output_fct(
      std::ostream& outfile,
      const unsigned& nplot,
      const double& time,
      FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt);


    /// Get error against and norm of exact solution
    void compute_error(std::ostream& outfile,
                       FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                       double& error,
                       double& norm);


    /// Get error against and norm of exact solution
    void compute_error(std::ostream& outfile,
                       FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                       const double& time,
                       double& error,
                       double& norm);


    /// Access function: Pointer to evaporation flux
    EvaporationFluxPt& evap_flux_pt()
    {
      return Evap_flux_pt;
    }


    /// Access function: Pointer to evaporation flux. Const version
    EvaporationFluxPt evap_flux_pt() const
    {
      return Evap_flux_pt;
    }

    /// Access function: Pointer to transition function
    TransitionFctPt& transition_fct_pt()
    {
      return Transition_fct_pt;
    }

    /// Access function: Pointer to transition function. Const version
    TransitionFctPt transition_fct_pt() const
    {
      return Transition_fct_pt;
    }

    /// Access function: Pointer to transition function derivative
    TransitionFctPt& transition_fct_deriv_pt()
    {
      return Transition_fct_deriv_pt;
    }

    /// Access function: Pointer to to transition function derivative. Const
    /// version
    TransitionFctPt transition_fct_deriv_pt() const
    {
      return Transition_fct_deriv_pt;
    }

    /// Access function: Pointer to mobility function
    MobilityFctPt& mobility_fct_pt()
    {
      return Mobility_fct_pt;
    }

    /// Access function: Pointer to mobility function. Const version
    MobilityFctPt mobility_fct_pt() const
    {
      return Mobility_fct_pt;
    }

    /// Access function: Pointer to solute mobility function
    MobilityFctPt& solute_mobility_fct_pt()
    {
      return Solute_mobility_fct_pt;
    }

    /// Access function: Pointer to solute mobility function. Const version
    MobilityFctPt solute_mobility_fct_pt() const
    {
      return Solute_mobility_fct_pt;
    }

    /// Access function: Pointer to mobility function derivative (w.r.t h)
    MobilityFctPt& mobility_fct_deriv_h_pt()
    {
      return Mobility_fct_deriv_h_pt;
    }

    /// Access function: Pointer to mobility function derivative (w.r.t. h).
    /// Const version
    MobilityFctPt mobility_fct_deriv_h_pt() const
    {
      return Mobility_fct_deriv_h_pt;
    }

    /// Access function: Pointer to mobility function derivative (w.r.t. c)
    MobilityFctPt& mobility_fct_deriv_c_pt()
    {
      return Mobility_fct_deriv_c_pt;
    }

    /// Access function: Pointer to mobility function derivative (w.r.t. c).
    /// Const version
    MobilityFctPt mobility_fct_deriv_c_pt() const
    {
      return Mobility_fct_deriv_c_pt;
    }

    /// Access function: Pointer to solute mobility function derivative (w.r.t
    /// h)
    MobilityFctPt& solute_mobility_fct_deriv_h_pt()
    {
      return Solute_mobility_fct_deriv_h_pt;
    }

    /// Access function: Pointer to solute mobility function derivative (w.r.t.
    /// h). Const version
    MobilityFctPt solute_mobility_fct_deriv_h_pt() const
    {
      return Solute_mobility_fct_deriv_h_pt;
    }

    /// Access function: Pointer to solute mobility function derivative (w.r.t.
    /// c)
    MobilityFctPt& solute_mobility_fct_deriv_c_pt()
    {
      return Solute_mobility_fct_deriv_c_pt;
    }

    /// Access function: Pointer to solute mobility function derivative (w.r.t.
    /// c). Const version
    MobilityFctPt solute_mobility_fct_deriv_c_pt() const
    {
      return Solute_mobility_fct_deriv_c_pt;
    }

    /// Get source term at continous time t and (Eulerian) position x.
    /// Virtual so it can be overloaded in derived multiphysics elements.
    virtual inline void get_evap_flux_thin_film_brinkman(
      const double& t,
      const unsigned& ipt,
      const Vector<double>& x,
      double& evap) const
    {
      // If no source function has been set, return zero
      if (Evap_flux_pt == 0)
      {
        evap = 0.0;
      }
      else
      {
        // Get source strength
        (*Evap_flux_pt)(t, x, evap);
      }
    }

    /// Get transition function for a given value of c.
    /// Virtual so it can be overloaded in derived multiphysics elements.
    virtual inline void get_transition_fct_thin_film_brinkman(
      const unsigned& ipt, const double& c, double& H) const
    {
      // If no source function has been set, return 1
      if (Transition_fct_pt == 0)
      {
        H = 1.0;
      }
      else
      {
        // Get source strength
        (*Transition_fct_pt)(c, H);
      }
    }

    /// Get transition function derivative for a given value of c.
    virtual inline void get_transition_fct_deriv_thin_film_brinkman(
      const unsigned& ipt, const double& c, double& dHdc) const
    {
      // If nothing set, return 0
      if (Transition_fct_deriv_pt == 0)
      {
        dHdc = 0.0;
      }
      else
      {
        // Get source strength derivative
        (*Transition_fct_deriv_pt)(c, dHdc);
      }
    }

    /// Get mobility function for given h and c
    virtual inline void get_mobility_thin_film_brinkman(const unsigned& ipt,
                                                        const double& h,
                                                        const double& c,
                                                        double& Q) const
    {
      // If nothing set, return 1
      if (Mobility_fct_pt == 0)
      {
        Q = 1.0;
      }
      else
      {
        // Get mobility value
        (*Mobility_fct_pt)(h, c, Q);
      }
    }

    /// Get mobility derivative (w.r.t. h)
    virtual inline void get_mobility_deriv_h_thin_film_brinkman(
      const unsigned& ipt, const double& h, const double& c, double& dQdh) const
    {
      // If nothing set, return 0
      if (Mobility_fct_deriv_h_pt == 0)
      {
        dQdh = 0.0;
      }
      else
      {
        // Get mobility derivative
        (*Mobility_fct_deriv_h_pt)(h, c, dQdh);
      }
    }

    /// Get mobility derivative (w.r.t. h)
    virtual inline void get_mobility_deriv_c_thin_film_brinkman(
      const unsigned& ipt, const double& h, const double& c, double& dQdc) const
    {
      // If nothing set, return 0
      if (Mobility_fct_deriv_c_pt == 0)
      {
        dQdc = 0.0;
      }
      else
      {
        // Get mobility derivative
        (*Mobility_fct_deriv_c_pt)(h, c, dQdc);
      }
    }

    /// Get solute mobility function for given h and c
    virtual inline void get_solute_mobility_thin_film_brinkman(
      const unsigned& ipt, const double& h, const double& c, double& Q) const
    {
      // If nothing set, return 1
      if (Solute_mobility_fct_pt == 0)
      {
        Q = 1.0;
      }
      else
      {
        // Get mobility value
        (*Solute_mobility_fct_pt)(h, c, Q);
      }
    }

    /// Get mobility derivative (w.r.t. h)
    virtual inline void get_solute_mobility_deriv_h_thin_film_brinkman(
      const unsigned& ipt, const double& h, const double& c, double& dQdh) const
    {
      // If nothing set, return 0
      if (Solute_mobility_fct_deriv_h_pt == 0)
      {
        dQdh = 0.0;
      }
      else
      {
        // Get mobility derivative
        (*Solute_mobility_fct_deriv_h_pt)(h, c, dQdh);
      }
    }

    /// Get mobility derivative (w.r.t. h)
    virtual inline void get_solute_mobility_deriv_c_thin_film_brinkman(
      const unsigned& ipt, const double& h, const double& c, double& dQdc) const
    {
      // If nothing set, return 0
      if (Solute_mobility_fct_deriv_c_pt == 0)
      {
        dQdc = 0.0;
      }
      else
      {
        // Get mobility derivative
        (*Solute_mobility_fct_deriv_c_pt)(h, c, dQdc);
      }
    }

    /// Peclet number
    const double& peclet() const
    {
      return *Pe_pt;
    }

    /// Pointer to Peclet number
    double*& peclet_pt()
    {
      return Pe_pt;
    }

    /// Dry-out time
    const double& t_f() const
    {
      return *Dry_out_time_pt;
    }

    /// Pointer to the dry-out time
    double*& t_f_pt()
    {
      return Dry_out_time_pt;
    }

    /// Axisymmetry flag
    const bool& axisymmetry_flag() const
    {
      return *Axisymmetry_flag_pt;
    }

    /// Pointer to axisymmetry flag
    bool*& axisymmetry_flag_pt()
    {
      return Axisymmetry_flag_pt;
    }

    /// Evaporation at integration points
    const Vector<double>& evap_at_int_points() const
    {
      return *Evap_at_int_points_pt;
    }

    /// Pointer to evaporation at integration points
    Vector<double>*& evap_at_int_points_pt()
    {
      return Evap_at_int_points_pt;
    }

    /// Get flux: flux[i] = du/dx_i
    void get_flux(const Vector<double>& s, Vector<double>& flux) const
    {
      // Find out how many nodes there are in the element
      unsigned n_node = nnode();

      // Set up memory for the shape and test functions
      Shape psi(n_node);
      DShape dpsidx(n_node, DIM);

      // Call the derivatives of the shape and test functions
      dshape_eulerian(s, psi, dpsidx);

      // Initialise to zero
      for (unsigned j = 0; j < 3 * DIM; j++)
      {
        flux[j] = 0.0;
      }

      // Loop over each variable h, \omega and c
      for (unsigned i = 0; i < 3; i++)
      {
        // Find the index at which the variable is stored
        unsigned u_nodal_index = u_index_thin_film_brinkman(i);

        // Loop over derivative directions
        for (unsigned j = 0; j < DIM; j++)
        {
          unsigned index = i * DIM + j;
          // Loop over nodes
          for (unsigned l = 0; l < n_node; l++)
          {
            flux[index] += nodal_value(l, u_nodal_index) * dpsidx(l, j);
          }
        }
      }
    }

    /// Get the total solutal flux
    void get_solutal_flux(const Vector<double>& s,
                          Vector<double>& solutal_flux) const
    {
      // Find out how many nodes there are in the element
      const unsigned n_node = nnode();

      // Get the nodal index at which the unknown is stored
      unsigned u_nodal_index;

      // Set up memory for the shape and test functions
      Shape psi(n_node);
      DShape dpsidx(n_node, DIM);

      // Call the derivatives of the shape and test functions
      dshape_eulerian(s, psi, dpsidx);

      // Storage for the Eulerian position
      Vector<double> interpolated_x(DIM, 0.0);
      // Storage for solution vector
      Vector<double> interpolated_u(3, 0.0);
      // Storage for the derivatives of solution vector
      DenseMatrix<double> interpolated_dudx(3, DIM, 0.0);

      // Loop over variables
      for (unsigned a = 0; a < 3; a++)
      {
        u_nodal_index = u_index_thin_film_brinkman(a);
        // Loop over nodes
        for (unsigned l = 0; l < n_node; l++)
        {
          // Get the value at the node
          const double u_value = this->nodal_value(l, u_nodal_index);
          interpolated_u[a] += u_value * psi(l);
          // Loop over directions
          for (unsigned j = 0; j < DIM; j++)
          {
            interpolated_x[j] += this->nodal_position(l, j) * psi(l);
            interpolated_dudx(a, j) += u_value * dpsidx(l, j);
          }
        }
      }

      // Dummy integration point
      unsigned ipt = 0;

      // Get the solute mobility
      double solute_mobility;
      get_solute_mobility_thin_film_brinkman(
        ipt, interpolated_u[0], interpolated_u[2], solute_mobility);

      // Calculate the total flux made up of the diffusive flux
      // and the conserved wind
      for (unsigned i = 0; i < DIM; i++)
      {
        // Initialize to zero
        solutal_flux[i] = 0.0;

        // Advective term
        solutal_flux[i] +=
          solute_mobility * interpolated_dudx(1, i) * interpolated_u[2];

        // Diffusive term
        solutal_flux[i] -=
          pow(peclet(), -1.0) * interpolated_u[0] * interpolated_dudx(2, i);
      }
    }


    /// Compute element residual Vector (wrapper)
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic residuals function with flag set to 0
      // using a dummy matrix argument
      fill_in_generic_residual_contribution_thin_film_brinkman(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    // Compute element residual Vector and element Jacobian matrix (wrapper)
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      fill_in_generic_residual_contribution_thin_film_brinkman(
        residuals, jacobian, 1);
    }

    /// Return FE representation of function value u(s) at local coordinate s
    inline double interpolated_u_thin_film_brinkman(const Vector<double>& s,
                                                    const unsigned i) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Find the index at which the variable is stored
      unsigned u_nodal_index = u_index_thin_film_brinkman(i);

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);

      // Initialise value of u
      double interpolated_u = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_u += nodal_value(l, u_nodal_index) * psi[l];
      }

      return (interpolated_u);
    }


    /// Return FE representation of function value u(s) at local
    /// coordinate s at previous time t (t=0: present)
    inline double interpolated_u_thin_film_brinkman(const unsigned& t,
                                                    const Vector<double>& s,
                                                    const unsigned i) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Find the index at which the variable is stored
      unsigned u_nodal_index = u_index_thin_film_brinkman(i);

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);

      // Initialise value of u
      double interpolated_u = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_u += nodal_value(t, l, u_nodal_index) * psi[l];
      }

      return (interpolated_u);
    }


    /// Return FE representation of function value du/dt(s) at local coordinate
    /// s
    inline double interpolated_du_dt_thin_film_brinkman(const Vector<double>& s,
                                                        const unsigned i) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);

      // Initialise value of du/dt
      double interpolated_dudt = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_dudt += du_dt_thin_film_brinkman(l, i) * psi[l];
      }

      return (interpolated_dudt);
    }


    /// Self-test: Return 0 for OK
    unsigned self_test();


  protected:
    /// Shape/test functions and derivs w.r.t. to global coords at
    /// local coord. s; return  Jacobian of mapping
    virtual double dshape_and_dtest_eulerian_thin_film_brinkman(
      const Vector<double>& s,
      Shape& psi,
      DShape& dpsidx,
      Shape& test,
      DShape& dtestdx) const = 0;


    /// Shape/test functions and derivs w.r.t. to global coords at
    /// integration point ipt; return  Jacobian of mapping
    virtual double dshape_and_dtest_eulerian_at_knot_thin_film_brinkman(
      const unsigned& ipt,
      Shape& psi,
      DShape& dpsidx,
      Shape& test,
      DShape& dtestdx) const = 0;

    /// Compute element residual Vector only (if flag=and/or element
    /// Jacobian matrix
    virtual void fill_in_generic_residual_contribution_thin_film_brinkman(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag);

    /// Pointer to source function:
    EvaporationFluxPt Evap_flux_pt;

    /// Pointer to transition function
    TransitionFctPt Transition_fct_pt;

    /// Pointer to transition function derivative
    TransitionFctPt Transition_fct_deriv_pt;

    /// Pointer to mobility function
    MobilityFctPt Mobility_fct_pt;

    /// Pointer to mobility function derivative (w.r.t. h)
    MobilityFctPt Mobility_fct_deriv_h_pt;

    /// Pointer to mobility function derivative (w.r.t. c)
    MobilityFctPt Mobility_fct_deriv_c_pt;

    /// Pointer to solute mobility function
    MobilityFctPt Solute_mobility_fct_pt;

    /// Pointer to solute mobility function derivative (w.r.t. h)
    MobilityFctPt Solute_mobility_fct_deriv_h_pt;

    /// Pointer to solute mobility function derivative (w.r.t. c)
    MobilityFctPt Solute_mobility_fct_deriv_c_pt;

    /// Boolean flag to indicate if ALE formulation is disabled when
    /// time-derivatives are computed. Only set to true if you're sure
    /// that the mesh is stationary.
    bool ALE_is_disabled;

    // Pointer to the Peclet number
    double* Pe_pt;

    /// Pointer to dryout time
    double* Dry_out_time_pt;

    // Pointer to the axisymmetry flag
    bool* Axisymmetry_flag_pt;

    // Pointer to evaporation flux values at integration points
    Vector<double>* Evap_at_int_points_pt;

  private:
    /// Static default value for the Peclet number
    static double Default_peclet_number;

    /// Static default value for the axisymmetry flag
    static bool Default_axisymmetry_flag;

    /// Static default value for the dry-out time
    static double Default_dryout_time;
  };


  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////////


  //======================================================================
  /// QUnsteadyHeatElement elements are linear/quadrilateral/brick-shaped
  /// UnsteadyHeat elements with isoparametric interpolation for the function.
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class QThinFilmBrinkmanElement : public virtual QElement<DIM, NNODE_1D>,
                                   public virtual ThinFilmBrinkmanEquations<DIM>
  {
  private:
    /// Static array of ints to hold number of variables at
    /// nodes: Initial_Nvalue[n]
    static const unsigned Initial_Nvalue;

  public:
    /// Constructor: Call constructors for QElement and
    /// UnsteadyHeat equations
    QThinFilmBrinkmanElement()
      : QElement<DIM, NNODE_1D>(), ThinFilmBrinkmanEquations<DIM>()
    {
    }

    /// Broken copy constructor
    QThinFilmBrinkmanElement(
      const QThinFilmBrinkmanElement<DIM, NNODE_1D>& dummy) = delete;

    /// Broken assignment operator
    /*void operator=(const QUnsteadyHeatElement<DIM,NNODE_1D>&) = delete;*/

    ///  Required  # of `values' (pinned or dofs)
    /// at node n
    inline unsigned required_nvalue(const unsigned& n) const
    {
      return Initial_Nvalue;
    }

    /// Output function:
    ///  x,y,u   or    x,y,z,u
    void output(std::ostream& outfile)
    {
      ThinFilmBrinkmanEquations<DIM>::output(outfile);
    }


    ///  Output function:
    ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      ThinFilmBrinkmanEquations<DIM>::output(outfile, n_plot);
    }


    /// C-style output function:
    ///  x,y,u   or    x,y,z,u
    void output(FILE* file_pt)
    {
      ThinFilmBrinkmanEquations<DIM>::output(file_pt);
    }


    ///  C-style output function:
    ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      ThinFilmBrinkmanEquations<DIM>::output(file_pt, n_plot);
    }


    /// Output function for an exact solution:
    ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
    void output_fct(std::ostream& outfile,
                    const unsigned& n_plot,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt)
    {
      ThinFilmBrinkmanEquations<DIM>::output_fct(
        outfile, n_plot, exact_soln_pt);
    }


    /// Output function for a time-dependent exact solution.
    ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
    /// (Calls the steady version)
    void output_fct(std::ostream& outfile,
                    const unsigned& n_plot,
                    const double& time,
                    FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
    {
      ThinFilmBrinkmanEquations<DIM>::output_fct(
        outfile, n_plot, time, exact_soln_pt);
    }


  protected:
    /// Shape, test functions & derivs. w.r.t. to global coords. Return
    /// Jacobian.
    inline double dshape_and_dtest_eulerian_thin_film_brinkman(
      const Vector<double>& s,
      Shape& psi,
      DShape& dpsidx,
      Shape& test,
      DShape& dtestdx) const;


    /// Shape/test functions and derivs w.r.t. to global coords at
    /// integration point ipt; return  Jacobian of mapping
    inline double dshape_and_dtest_eulerian_at_knot_thin_film_brinkman(
      const unsigned& ipt,
      Shape& psi,
      DShape& dpsidx,
      Shape& test,
      DShape& dtestdx) const;
  };


  // Inline functions:


  //======================================================================
  /// Define the shape functions and test functions and derivatives
  /// w.r.t. global coordinates and return Jacobian of mapping.
  ///
  /// Galerkin: Test functions = shape functions
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  double QThinFilmBrinkmanElement<DIM, NNODE_1D>::
    dshape_and_dtest_eulerian_thin_film_brinkman(const Vector<double>& s,
                                                 Shape& psi,
                                                 DShape& dpsidx,
                                                 Shape& test,
                                                 DShape& dtestdx) const
  {
    // Call the geometrical shape functions and derivatives
    double J = this->dshape_eulerian(s, psi, dpsidx);

    // Loop over the test functions and derivatives and set them equal to the
    // shape functions
    for (unsigned i = 0; i < NNODE_1D; i++)
    {
      test[i] = psi[i];
      for (unsigned j = 0; j < DIM; j++)
      {
        dtestdx(i, j) = dpsidx(i, j);
      }
    }

    // Return the jacobian
    return J;
  }


  //======================================================================
  /// Define the shape functions and test functions and derivatives
  /// w.r.t. global coordinates and return Jacobian of mapping.
  ///
  /// Galerkin: Test functions = shape functions
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  double QThinFilmBrinkmanElement<DIM, NNODE_1D>::
    dshape_and_dtest_eulerian_at_knot_thin_film_brinkman(const unsigned& ipt,
                                                         Shape& psi,
                                                         DShape& dpsidx,
                                                         Shape& test,
                                                         DShape& dtestdx) const
  {
    // Call the geometrical shape functions and derivatives
    double J = this->dshape_eulerian_at_knot(ipt, psi, dpsidx);

    // Set the test functions equal to the shape functions
    //(sets internal pointers)
    test = psi;
    dtestdx = dpsidx;

    // Return the jacobian
    return J;
  }


  /// /////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the QUnsteadyHeatElement elements: The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<QThinFilmBrinkmanElement<DIM, NNODE_1D>>
    : public virtual QElement<DIM - 1, NNODE_1D>
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : QElement<DIM - 1, NNODE_1D>() {}
  };

  /// /////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the 1D QUnsteadyHeatElement elements: Point elements
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<QThinFilmBrinkmanElement<1, NNODE_1D>>
    : public virtual PointElement
  {
  public:
    /// Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : PointElement() {}
  };


  /// /////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////
  /// /////////////////////////////////////////////////////////////////////


  //   ==========================================================
  //   / UnsteadyHeat upgraded to become projectable
  //   ==========================================================
  template<class THIN_FILM_BRINKMAN_ELEMENT>
  class ProjectableThinFilmBrinkmanElement
    : public virtual ProjectableElement<THIN_FILM_BRINKMAN_ELEMENT>
  {
  public:
    // Constructor [this was only required explicitly
    // from gcc 4.5.2 onwards...]
    ProjectableThinFilmBrinkmanElement() {}

    // Specify the values associated with field fld.
    // The information is returned in a vector of pairs which comprise
    // the Data object and the value within it, that correspond to field fld.
    Vector<std::pair<Data*, unsigned>> data_values_of_field(const unsigned& fld)
    {
      // Create the vector
      unsigned nnod = this->nnode();
      Vector<std::pair<Data*, unsigned>> data_values(nnod);

      // Loop over all nodes
      for (unsigned j = 0; j < nnod; j++)
      {
        // Add the data value associated field: The node itself
        data_values[j] = std::make_pair(this->node_pt(j), fld);
      }

      // Return the vector
      return data_values;
    }

    // Number of fields to be projected: h and w
    unsigned nfields_for_projection()
    {
      return 3;
    }

    // Number of history values to be stored for fld-th field.
    // (Note: count includes current value!)
    unsigned nhistory_values_for_projection(const unsigned& fld)
    {
      return this->node_pt(0)->ntstorage();

      //       if (fld == 1)
      //       {
      //         return 1;
      //       }
      //       else
      //       {
      //         return this->node_pt(0)->ntstorage();
      //       }
    }

    // Number of positional history values
    // (Note: count includes current value!)
    unsigned nhistory_values_for_coordinate_projection()
    {
      return this->node_pt(0)->position_time_stepper_pt()->ntstorage();
    }

    // Return Jacobian of mapping and shape functions of field fld
    // at local coordinate s
    double jacobian_and_shape_of_field(const unsigned& fld,
                                       const Vector<double>& s,
                                       Shape& psi)
    {
      unsigned n_dim = this->dim();
      unsigned n_node = this->nnode();
      Shape test(n_node);
      DShape dpsidx(n_node, n_dim), dtestdx(n_node, n_dim);
      double J = this->dshape_and_dtest_eulerian_thin_film_brinkman(
        s, psi, dpsidx, test, dtestdx);
      return J;
    }


    // Return interpolated field fld at local coordinate s, at time
    // level t (t=0: present; t>0: history values)
    double get_field(const unsigned& t,
                     const unsigned& fld,
                     const Vector<double>& s)
    {
      // Find the index at which the variable is stored
      unsigned u_nodal_index = this->u_index_thin_film_brinkman(fld);

      // Local shape function
      unsigned n_node = this->nnode();
      Shape psi(n_node);

      // Find values of shape function
      this->shape(s, psi);

      // Initialise value of u
      double interpolated_u = 0.0;

      // Sum over the local nodes
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_u += this->nodal_value(t, l, u_nodal_index) * psi[l];
      }
      return interpolated_u;
    }


    // Return number of values in field fld: One per node
    unsigned nvalue_of_field(const unsigned& fld)
    {
      return this->nnode();
    }


    // Return local equation number of value j in field fld.
    int local_equation(const unsigned& fld, const unsigned& j)
    {
      const unsigned u_nodal_index = this->u_index_thin_film_brinkman(fld);
      return this->nodal_local_eqn(j, u_nodal_index);
    }


    // Output FE representation of soln: x,y,u or x,y,z,u at
    // and history values at n_plot^DIM plot points
    void output(std::ostream& outfile, const unsigned& nplot)
    {
      unsigned el_dim = this->dim();
      // Vector of local coordinates
      Vector<double> s(el_dim);

      // Tecplot header info
      //       outfile << this->tecplot_zone_string(nplot);
      
      // Find out how many nodes there are
      unsigned n_node = this->nnode();
      unsigned DIM = this->dim();
    
      // Set up memory for the shape functions
      Shape psif(n_node);
      DShape dpsifdx(n_node, DIM);        

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(nplot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, nplot, s);
        
        // Call the derivatives of the shape and test functions
        this->dshape_eulerian(s, psif, dpsifdx);
      
        // Allocate for pressure derivates
        Vector<double> interpolated_dpdx(DIM, 0.0);

        // Loop over nodes
        for (unsigned l = 0; l < n_node; l++)
        {
          // Loop over derivative directions for velocity gradients
          for (unsigned j = 0; j < DIM; j++)
          {
            interpolated_dpdx[j] +=
              this->nodal_value(l, 1) * dpsifdx(l, j);
          }
        }
      
        // Calculate the (solvent) velocity field:
        unsigned dummy_ipt = 0;
        double h_local = this->interpolated_u_thin_film_brinkman(s, 0);
        double phi_local = this->interpolated_u_thin_film_brinkman(s, 2);
        Vector<double> vel_field(DIM, 0.0);
        double mobility;
        this->get_mobility_thin_film_brinkman(
          dummy_ipt, h_local, phi_local, mobility);
        for (unsigned j = 0; j < DIM; j++)
        {
          vel_field[j] = mobility * interpolated_dpdx[j] / h_local;
        }

        for (unsigned i = 0; i < el_dim; i++)
        {
          outfile << this->interpolated_x(s, i) << " ";
        }
        for (unsigned i = 0; i < 3; i++)
        {
          outfile << this->interpolated_u_thin_film_brinkman(s, i) << " ";
         // outfile << this->interpolated_du_dt_thin_film_brinkman(s, i) << " ";
        }
        for (unsigned i = 0; i < DIM; i++)
        {
          outfile << vel_field[i] << " ";
        }
        outfile << std::endl;

      }
      // Write tecplot footer (e.g. FE connectivity lists)
      //       this->write_tecplot_zone_footer(outfile, nplot);
    }
  };


  //   =======================================================================
  //   / Face geometry for element is the same as that for the underlying
  //   / wrapped element
  //   =======================================================================
  template<class ELEMENT>
  class FaceGeometry<ProjectableThinFilmBrinkmanElement<ELEMENT>>
    : public virtual FaceGeometry<ELEMENT>
  {
  public:
    FaceGeometry() : FaceGeometry<ELEMENT>() {}
  };


  //   =======================================================================
  //   / Face geometry of the Face Geometry for element is the same as
  //   / that for the underlying wrapped element
  //   =======================================================================
  template<class ELEMENT>
  class FaceGeometry<FaceGeometry<ProjectableThinFilmBrinkmanElement<ELEMENT>>>
    : public virtual FaceGeometry<FaceGeometry<ELEMENT>>
  {
  public:
    FaceGeometry() : FaceGeometry<FaceGeometry<ELEMENT>>() {}
  };


} // namespace oomph

#endif
